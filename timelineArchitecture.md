## 타임라인
: 팔로우한 사용자의 게시물을 조회

### 1. Pull Model (Fan Out On Read)
#### 동작 방식
1. 사용자가 타임라인을 조회하면 **팔로우 목록을 조회**
2. 해당 **팔로우한 사용자의 게시물**을 검색하여 타임라인을 구성

#### 시간 복잡도
- `log(Follow 전체 레코드) + (Following 수 * log(Post 전체 레코드))`
- **팔로우 수가 많을수록 속도가 느려짐** (특히 인기 사용자 조회 시 부하가 큼)

#### 장점
- **정합성이 높음** → 원본 데이터를 실시간으로 조회하여 최신 상태 유지
- **저장 공간 절약** → 불필요한 중복 데이터 저장 X

#### 단점
- **조회 성능 문제** → 팔로우 수가 많을수록 쿼리 비용 증가
- **높은 동시성 부하** → 모든 사용자 요청 시 반복적으로 DB 조회

#### 실제 적용 사례
- **페이스북** → Pull 모델 사용 (팔로우 수 제한이 있음)

---

### 2. Push Model (Fan Out On Write)
#### 동작 방식
- **게시물 작성 시, 해당 작성자를 팔로우하는 모든 사용자에게 미리 전달**
- **타임라인 테이블을 별도로 두고, 팔로워들의 타임라인에 저장**

#### 시간 복잡도
- **쓰기 부하 증가** → `O(Follower 수)`
- **조회 부하 감소** → `O(1)`

#### 장점
- **조회 속도가 빠름** → 타임라인을 바로 가져올 수 있음
- **읽기 요청 부하 감소** → 조회 시점의 DB 부담 완화

#### 단점
- **저장 공간 문제** → 인기 계정(수백만 팔로워)일 경우, 중복 데이터 폭발
- **데이터 동기화 문제** → 게시물 수정/삭제 시 모든 타임라인을 업데이트해야 함

#### 실제 적용 사례
- **트위터** → Push 모델 사용

---

### 3. 정합성과 성능의 트레이드오프
| 모델 | 정합성 | 성능 (쓰기) | 성능 (읽기) | 저장 공간 |
|------|-------|------------|------------|----------|
| **Pull (Read 중심)** | 높음 | 빠름 | 느림 | 작음 |
| **Push (Write 중심)** | 낮음 | 느림 | 빠름 | 큼 |

- **Push Model** → **공간 복잡도를 희생**하고 **조회 성능 최적화**
- **Pull Model** → **시간 복잡도를 희생**하고 **정합성 유지**

---

### 4. CAP 이론과 타임라인 모델
**CAP 이론** (Consistency, Availability, Partition Tolerance)에서  
타임라인 시스템은 **정합성 vs 가용성** 사이에서 **트레이드오프**를 고려해야 함

- **Push 모델**은 **가용성(A)** 을 높이는 대신, 정합성(C)이 약해질 수 있음
- **Pull 모델**은 **정합성(C)** 을 유지하지만, 가용성(A)과 성능이 떨어질 수 있음

---

### 5. 추가 최적화 기법
#### 하이브리드 모델
- **일반 사용자는 Push (미리 저장)**
- **팔로워가 많은 VIP 사용자는 Pull (실시간 조회)**
- **캐싱 활용 (Redis, Kafka)로 조회 부하 감소**

#### 비동기 처리 (Event Queue 활용)
- 게시물 저장 후 **Kafka, RabbitMQ** 등의 메시지 큐를 활용해 **비동기 분배**
- 즉시 반영하지 않고 **배치로 업데이트**하여 성능 최적화

---

### 6. 결론
- **팔로우 수가 적은 서비스** → **Push 모델**이 유리
- **팔로우 수가 많은 서비스** → **Pull 모델 + 캐싱 최적화**
- **하이브리드 모델**이 현실적으로 가장 많이 사용됨 (트위터 방식)

타임라인 시스템을 설계할 때 서비스 특성에 따라 최적의 방식을 선택해야 함
