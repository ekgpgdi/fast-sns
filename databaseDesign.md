## 데이터베이스

<br/>

### 데이터베이스 성능

|        | 메모리 (RAM) | 디스크 (HDD/SSD) |
|--------|------------|----------------|
| **속도** | 빠름       | 느림           |
| **영속성** | 전원이 공급되지 않으면 휘발 | 영속성이 있음 |
| **가격**  | 비쌈       | 저렴함         |

> 데이터베이스의 데이터는 결국 디스크에 저장됨  
> 따라서 **데이터베이스 성능의 핵심은 디스크 I/O(입출력) 최소화**에 있음


#### 디스크 I/O 최소화를 위한 전략

1. ✅ **메모리 캐시 활용**
- 디스크 접근을 줄이기 위해 **메모리에 있는 데이터로 최대한 요청을 처리**해야 함.
- 이를 통해 **캐시 히트율**을 높이고 성능을 개선

2. ✅ **쓰기(Write) 최적화**
- 데이터를 바로 디스크에 쓰지 않고 **먼저 메모리에 저장**하여 랜덤 I/O를 줄임
- 하지만, 메모리에 저장된 데이터가 디스크에 기록되지 못한 채 서버가 다운되면 데이터가 유실될 수 있음

3. ✅ **WAL (Write Ahead Log) 사용**
- 데이터 유실을 방지하기 위해 **WAL(Write Ahead Log)** 를 사용하여 변경 이력을 먼저 로그로 남김
- 만약 서버가 다운되더라도 WAL을 이용해 데이터를 복구할 수 있음

#### 디스크 접근 방식

- **랜덤 I/O (Random I/O)**: 무작위 위치에서 데이터를 읽고 씀 → **성능 저하**
- **순차 I/O (Sequential I/O)**: 연속된 데이터 블록을 읽고 씀 → **성능 향상**

> 대부분의 트랜잭션은 무작위로 Write가 발생함  
> 따라서 **이를 지연시켜 랜덤 I/O 횟수를 줄이고, 대신 순차적 I/O를 유도하면 성능이 개선됨**

#### 💡 결론
✅ **업데이트가 올 때마다 디스크에 데이터를 저장하면 비효율적**  
✅ **메모리에 데이터를 쌓아두었다가 한 번에 디스크로 저장하는 것이 성능적으로 유리**  
✅ **디스크의 랜덤 I/O를 최소화하는 것이 데이터베이스 성능 최적화의 핵심**

<br/>

### 인덱스

인덱스는 **정렬된 자료 구조**로, **탐색 범위를 최소화**하여 조회 성능을 높인다.  
하지만 **삽입/삭제 성능**을 저하시킬 수 있다. 인덱스는 **조회 성능을 높이지만, 삽입/삭제 시 성능 저하**를 발생시킨다.

> **인덱스도 하나의 테이블이다.**

#### 자료구조

- **B+ Tree**
    - 삽입/삭제 시 항상 균형을 이룬다.
    - **리프 노드에 데이터 존재** → 연속 데이터 접근 시 유리.

- **MySQL**의 인덱스는 **PK 인덱스**와 매칭, **Oracle**은 데이터 주소를 사용한다.

#### 클러스터 인덱스

- **클러스터 인덱스**는 **데이터 위치를 결정**하는 키 값이다.
- **PK는 클러스터 인덱스**다.
- **PK 제외 인덱스**는 **PK를 포함**한다.
- **정렬된 순서**로 저장 → **삽입 시 성능 저하** 발생 가능.

#### 세컨더리 인덱스

- 세컨더리 인덱스만으로는 데이터를 찾을 수 없다.
- **세컨더리 인덱스**는 **PK를 포함**해 **커버링 인덱스**를 가능하게 한다.  
  → 테이블에 접근하지 않고 인덱스만으로 데이터를 조회할 수 있다.

#### 장점

1. **PK 활용 검색이 빠름**, 특히 **범위 검색**에서 성능 우위 → **공간적 캐시 이점**.
2. **세컨더리 인덱스는 PK 포함** → **커버링 인덱스** 활용 가능.

### 실습
```sql
# 데이터 분포도에 따라 같은 인덱스여도 성능이 다를 수 있다.
# 데이터 식별성에 따라 성능이 크게 달라짐

# 약 270만개 데이터 조회 40s 432ms > 인덱스를 주지 않았을 때보다 느려짐
# 범위의 조건을 좁힐 수 없음 (현재 1번 유저의 데이터만 있기에)
# 인덱스 테이블도 보고, 물리 테이블도 봐야 하기에 역효과 발생
create index POST__index_member_id
    on POST (memberId);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_member_id)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;

# 약 270만개 데이터 조회 2s 489ms
# 식별값이 많기에, 대신 데이터가 없는 memberId 인 경우 엄청 느려짐
create index POST__index_created_date
    on POST (createdDate);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_created_date)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;

# 약 270만개 데이터 조회 129ms
# 복합 인덱스로 추가
create index POST__index_member_id_created_date
    on POST (memberId, createdDate);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_member_id_created_date)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;
```

### 인덱스를 다룰 때 주의해야 할 점

#### 1. 인덱스 필드 가공
- 인덱스 필드를 가공하면 인덱스를 사용할 수 없음.
    - 예시: `age`가 인덱스가 있다고 해도, `WHERE age * 10 = 1` 쿼리에서는 인덱스를 사용하지 않음.
    - 예시: `WHERE age = '1'`과 같이 타입이 잘못된 경우에도 인덱스를 사용할 수 없음.

#### 2. 복합 인덱스
- 복합 인덱스는 인덱스에 명시된 순서대로 정렬됨.
    - 예시: `A, B` 복합 인덱스에서 `WHERE B`만 사용할 경우 인덱스를 사용하지 않음.
    - **제일 선두 컬럼이 중요**: 복합 인덱스에서 효율적인 사용을 위해 첫 번째 컬럼이 쿼리 조건에 있어야 함.

#### 3. 하나의 쿼리에는 하나의 인덱스만 사용
- 하나의 쿼리에서 여러 인덱스를 동시에 탐색하지 않음.
    - 예외적으로 `index merge hint`를 사용하면 여러 인덱스를 동시에 사용할 수 있음.
- `WHERE`, `ORDER BY`, `GROUP BY`와 같은 조건을 혼합하여 사용할 때 인덱스를 잘 고려해야 함.

#### 추가 사항
- 의도대로 인덱스가 동작하지 않을 수 있으므로, **`EXPLAIN`**을 통해 확인해야 함.
- 인덱스는 비용이 발생함. **쓰기를 희생하고 조회 성능을 얻는 것**이므로 이를 고려해야 함.
- **인덱스로만 해결할 수 있는 문제인지**를 신중하게 판단해야 함.


<br/>


### ACID
데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어

#### A. 원자성 (Atomicity)
원자적 연산을 보장해야 함
- **All OR Nothing** 원칙
- MySQL에서는 **MVCC**를 통해 지원
- 트랜잭션 시작 시 **Undo Log**에 원본 데이터를 저장하고, 트랜잭션 실패 시 되돌림

#### C. 일관성 (Consistency)
트랜잭션이 종료되었을 때 무결성이 보장되어야 함
- **제약 조건**을 통해 보장 (유니크 제약, 외래키 제약 등)

#### I. 독립성 (Isolation)
트랜잭션은 서로 간섭하지 않고 독립적으로 동작해야 함
- 성능 이슈로 인해 가장 유연성이 있는 제약 조건
- 높은 성능을 위해 개발자가 직접 제어 가능
- **트랜잭션 격리 레벨**을 통해 제어

#### D. 지속성 (Durability)
완료된 트랜잭션은 유실되지 않음
- **WAL (Write-Ahead Logging)** 을 통해 보장
  - 변경 사항을 먼저 로그에 기록한 후 데이터베이스에 반영 (순차적으로 로그 저장)

<br/>

### MVCC 
(Multi-Version Concurrency Control) 다중 버전 동시성 제어 기법으로, 트랜잭션 간의 충돌을 줄이고 읽기 작업이 쓰기 작업을 방해하지 않도록 함

#### MVCC의 동작 방식
- **각 트랜잭션은 특정 시점(Snapshot)의 데이터를 읽음** → 다른 트랜잭션의 변경 사항을 보지 않음
- **쓰기 작업이 발생하면 새로운 버전을 생성** → 기존 데이터를 변경하지 않고 새 버전으로 관리
- **Undo Log를 활용하여 롤백 가능**

#### MVCC의 장점
- **읽기 작업이 블로킹되지 않음** → SELECT 쿼리가 쓰기 트랜잭션을 기다릴 필요 없음
- **Deadlock 발생 가능성이 낮음** → 대부분의 읽기 작업이 기존 데이터를 그대로 참조하기 때문

#### MVCC를 지원하는 DBMS
- **MySQL (InnoDB)**
- **PostgreSQL**
- **Oracle (부분 지원)**


<br/>

### 트랜잭션 격리 레벨과 이상 현상

1. **Dirty Read**: 커밋되지 않은 데이터를 읽음
  - 트랜잭션 A가 데이터를 수정하고 커밋하지 않은 상태에서, 트랜잭션 B가 그 데이터를 읽는 현상. 이 경우 트랜잭션 A가 롤백되면, 트랜잭션 B는 잘못된 데이터를 읽은 셈이 됩니다

2. **Non Repeatable Read**: 하나의 트랜잭션에서 같은 데이터를 읽을 때 다른 결과를 얻음
  - 트랜잭션 A가 데이터를 읽은 후, 트랜잭션 B가 그 데이터를 수정하거나 삭제한 뒤, 트랜잭션 A가 다시 데이터를 읽을 때 이전과 다른 결과를 얻는 현상

3. **Phantom Read**: 같은 조건으로 데이터를 읽었을 때 데이터 셋 결과가 달라지는 현상
  - 트랜잭션 A가 특정 조건으로 데이터를 읽은 후, 트랜잭션 B가 그 조건에 맞는 데이터를 삽입, 삭제, 업데이트한 후, 트랜잭션 A가 다시 데이터를 읽을 때 결과 셋이 달라지는 현상

#### 1. Read Uncommitted
- **Dirty Read**: 허용
- **Non Repeatable Read**: 허용
- **Phantom Read**: 허용

Read Uncommitted는 가장 낮은 격리 수준으로, 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있습니다. 이로 인해 여러 가지 이상 현상이 발생할 수 있습니다.

#### 2. Read Committed
- **Dirty Read**: 허용 안됨
- **Non Repeatable Read**: 허용
- **Phantom Read**: 허용

Read Committed는 커밋된 데이터만 읽을 수 있기 때문에, Dirty Read는 발생하지 않지만 Non Repeatable Read와 Phantom Read는 여전히 발생할 수 있습니다.

#### 3. Repeable Read
- **Dirty Read**: 허용 안됨
- **Non Repeatable Read**: 허용 안됨
- **Phantom Read**: 허용

Repeable Read는 트랜잭션이 실행되는 동안 동일한 데이터를 여러 번 읽더라도 항상 동일한 값을 반환합니다. 트랜잭션 간에 데이터 변경을 방지하여 Non Repeatable Read를 방지하지만, 여전히 Phantom Read 현상이 발생할 수 있습니다. 트랜잭션 ID를 부여하여 다른 트랜잭션이 해당 트랜잭션보다 낮게 들어오는 트랜잭션을 볼 수 없게 만듭니다.

#### 4. Serializable
- **Dirty Read**: 허용 안됨
- **Non Repeatable Read**: 허용 안됨
- **Phantom Read**: 허용 안됨

Serializable은 가장 높은 격리 수준으로, 트랜잭션이 다른 트랜잭션의 영향을 전혀 받지 않도록 보장합니다. 이 격리 수준에서는 모든 이상 현상이 발생하지 않습니다. 하지만, 동시 처리량이 낮고 성능에 영향을 미칠 수 있습니다.

### 격리 수준에 따른 이상 현상 발생 여부

| 격리 레벨           | Dirty Read | Non Repeatable Read | Phantom Read |
|---------------------|------------|----------------------|--------------|
| Read Uncommitted    | O          | O                    | O            |
| Read Committed      | X          | O                    | O            |
| Repeable Read       | X          | X                    | O            |
| Serializable        | X          | X                    | X            |

### 동시 처리량과 격리 레벨

- **Read Uncommitted**는 동시 처리량이 가장 높지만, 많은 이상 현상을 허용합니다.
- **Read Committed**나 **Repeable Read**는 이상 현상이 적고 안정적이지만, 동시 처리량이 낮습니다.
- **Repeable Read**는 데드락 이슈가 발생할 수 있어 **Read Committed**가 더 많이 사용됩니다.
- **Serializable**는 가장 높은 격리 수준이지만, 성능에 큰 영향을 미치므로 사용이 드뭅니다.


**Read Committed**와 **Repeable Read**는 균형을 잘 맞춘 격리 레벨로, 대부분의 상황에서 자주 사용됩니다. <br/>
하지만 **Repeable Read**는 데드락을 유발할 수 있으므로 **Read Committed**가 더 많이 사용됩니다. <br/>
