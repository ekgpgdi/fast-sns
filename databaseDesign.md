## 데이터베이스

<br/>

### 데이터베이스 성능

|        | 메모리 (RAM) | 디스크 (HDD/SSD) |
|--------|------------|----------------|
| **속도** | 빠름       | 느림           |
| **영속성** | 전원이 공급되지 않으면 휘발 | 영속성이 있음 |
| **가격**  | 비쌈       | 저렴함         |

> 데이터베이스의 데이터는 결국 디스크에 저장됨  
> 따라서 **데이터베이스 성능의 핵심은 디스크 I/O(입출력) 최소화**에 있음


#### 디스크 I/O 최소화를 위한 전략

1. ✅ **메모리 캐시 활용**
- 디스크 접근을 줄이기 위해 **메모리에 있는 데이터로 최대한 요청을 처리**해야 함.
- 이를 통해 **캐시 히트율**을 높이고 성능을 개선

2. ✅ **쓰기(Write) 최적화**
- 데이터를 바로 디스크에 쓰지 않고 **먼저 메모리에 저장**하여 랜덤 I/O를 줄임
- 하지만, 메모리에 저장된 데이터가 디스크에 기록되지 못한 채 서버가 다운되면 데이터가 유실될 수 있음

3. ✅ **WAL (Write Ahead Log) 사용**
- 데이터 유실을 방지하기 위해 **WAL(Write Ahead Log)** 를 사용하여 변경 이력을 먼저 로그로 남김
- 만약 서버가 다운되더라도 WAL을 이용해 데이터를 복구할 수 있음

#### 디스크 접근 방식

- **랜덤 I/O (Random I/O)**: 무작위 위치에서 데이터를 읽고 씀 → **성능 저하**
- **순차 I/O (Sequential I/O)**: 연속된 데이터 블록을 읽고 씀 → **성능 향상**

> 대부분의 트랜잭션은 무작위로 Write가 발생함  
> 따라서 **이를 지연시켜 랜덤 I/O 횟수를 줄이고, 대신 순차적 I/O를 유도하면 성능이 개선됨**

#### 💡 결론
✅ **업데이트가 올 때마다 디스크에 데이터를 저장하면 비효율적**  
✅ **메모리에 데이터를 쌓아두었다가 한 번에 디스크로 저장하는 것이 성능적으로 유리**  
✅ **디스크의 랜덤 I/O를 최소화하는 것이 데이터베이스 성능 최적화의 핵심**

<br/>

### 인덱스

인덱스는 **정렬된 자료 구조**로, **탐색 범위를 최소화**하여 조회 성능을 높인다.  
하지만 **삽입/삭제 성능**을 저하시킬 수 있다. 인덱스는 **조회 성능을 높이지만, 삽입/삭제 시 성능 저하**를 발생시킨다.

> **인덱스도 하나의 테이블이다.**

#### 자료구조

- **B+ Tree**
    - 삽입/삭제 시 항상 균형을 이룬다.
    - **리프 노드에 데이터 존재** → 연속 데이터 접근 시 유리.

- **MySQL**의 인덱스는 **PK 인덱스**와 매칭, **Oracle**은 데이터 주소를 사용한다.

#### 클러스터 인덱스

- **클러스터 인덱스**는 **데이터 위치를 결정**하는 키 값이다.
- **PK는 클러스터 인덱스**다.
- **PK 제외 인덱스**는 **PK를 포함**한다.
- **정렬된 순서**로 저장 → **삽입 시 성능 저하** 발생 가능.

#### 세컨더리 인덱스

- 세컨더리 인덱스만으로는 데이터를 찾을 수 없다.
- **세컨더리 인덱스**는 **PK를 포함**해 **커버링 인덱스**를 가능하게 한다.  
  → 테이블에 접근하지 않고 인덱스만으로 데이터를 조회할 수 있다.

#### 장점

1. **PK 활용 검색이 빠름**, 특히 **범위 검색**에서 성능 우위 → **공간적 캐시 이점**.
2. **세컨더리 인덱스는 PK 포함** → **커버링 인덱스** 활용 가능.

### 실습
```sql
# 데이터 분포도에 따라 같은 인덱스여도 성능이 다를 수 있다.
# 데이터 식별성에 따라 성능이 크게 달라짐

# 약 270만개 데이터 조회 40s 432ms > 인덱스를 주지 않았을 때보다 느려짐
# 범위의 조건을 좁힐 수 없음 (현재 1번 유저의 데이터만 있기에)
# 인덱스 테이블도 보고, 물리 테이블도 봐야 하기에 역효과 발생
create index POST__index_member_id
    on POST (memberId);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_member_id)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;

# 약 270만개 데이터 조회 2s 489ms
# 식별값이 많기에, 대신 데이터가 없는 memberId 인 경우 엄청 느려짐
create index POST__index_created_date
    on POST (createdDate);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_created_date)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;

# 약 270만개 데이터 조회 129ms
# 복합 인덱스로 추가
create index POST__index_member_id_created_date
    on POST (memberId, createdDate);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_member_id_created_date)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;
```

### 인덱스를 다룰 때 주의해야 할 점

#### 1. 인덱스 필드 가공
- 인덱스 필드를 가공하면 인덱스를 사용할 수 없음.
    - 예시: `age`가 인덱스가 있다고 해도, `WHERE age * 10 = 1` 쿼리에서는 인덱스를 사용하지 않음.
    - 예시: `WHERE age = '1'`과 같이 타입이 잘못된 경우에도 인덱스를 사용할 수 없음.

#### 2. 복합 인덱스
- 복합 인덱스는 인덱스에 명시된 순서대로 정렬됨.
    - 예시: `A, B` 복합 인덱스에서 `WHERE B`만 사용할 경우 인덱스를 사용하지 않음.
    - **제일 선두 컬럼이 중요**: 복합 인덱스에서 효율적인 사용을 위해 첫 번째 컬럼이 쿼리 조건에 있어야 함.

#### 3. 하나의 쿼리에는 하나의 인덱스만 사용
- 하나의 쿼리에서 여러 인덱스를 동시에 탐색하지 않음.
    - 예외적으로 `index merge hint`를 사용하면 여러 인덱스를 동시에 사용할 수 있음.
- `WHERE`, `ORDER BY`, `GROUP BY`와 같은 조건을 혼합하여 사용할 때 인덱스를 잘 고려해야 함.

#### 추가 사항
- 의도대로 인덱스가 동작하지 않을 수 있으므로, **`EXPLAIN`**을 통해 확인해야 함.
- 인덱스는 비용이 발생함. **쓰기를 희생하고 조회 성능을 얻는 것**이므로 이를 고려해야 함.
- **인덱스로만 해결할 수 있는 문제인지**를 신중하게 판단해야 함.


<br/>


### ACID
데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어

#### A. 원자성 (Atomicity)
원자적 연산을 보장해야 함
- **All OR Nothing** 원칙
- MySQL에서는 **MVCC**를 통해 지원
- 트랜잭션 시작 시 **Undo Log**에 원본 데이터를 저장하고, 트랜잭션 실패 시 되돌림

#### C. 일관성 (Consistency)
트랜잭션이 종료되었을 때 무결성이 보장되어야 함
- **제약 조건**을 통해 보장 (유니크 제약, 외래키 제약 등)

#### I. 독립성 (Isolation)
트랜잭션은 서로 간섭하지 않고 독립적으로 동작해야 함
- 성능 이슈로 인해 가장 유연성이 있는 제약 조건
- 높은 성능을 위해 개발자가 직접 제어 가능
- **트랜잭션 격리 레벨**을 통해 제어

#### D. 지속성 (Durability)
완료된 트랜잭션은 유실되지 않음
- **WAL (Write-Ahead Logging)** 을 통해 보장
  - 변경 사항을 먼저 로그에 기록한 후 데이터베이스에 반영 (순차적으로 로그 저장)

<br/>

### MVCC 
(Multi-Version Concurrency Control) 다중 버전 동시성 제어 기법으로, 트랜잭션 간의 충돌을 줄이고 읽기 작업이 쓰기 작업을 방해하지 않도록 함

#### MVCC의 동작 방식
- **각 트랜잭션은 특정 시점(Snapshot)의 데이터를 읽음** → 다른 트랜잭션의 변경 사항을 보지 않음
- **쓰기 작업이 발생하면 새로운 버전을 생성** → 기존 데이터를 변경하지 않고 새 버전으로 관리
- **Undo Log를 활용하여 롤백 가능**

#### MVCC의 장점
- **읽기 작업이 블로킹되지 않음** → SELECT 쿼리가 쓰기 트랜잭션을 기다릴 필요 없음
- **Deadlock 발생 가능성이 낮음** → 대부분의 읽기 작업이 기존 데이터를 그대로 참조하기 때문

#### MVCC를 지원하는 DBMS
- **MySQL (InnoDB)**
- **PostgreSQL**
- **Oracle (부분 지원)**