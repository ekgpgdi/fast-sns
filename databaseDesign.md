## 데이터베이스

<br/>

### 데이터베이스 성능

|        | 메모리 (RAM) | 디스크 (HDD/SSD) |
|--------|------------|----------------|
| **속도** | 빠름       | 느림           |
| **영속성** | 전원이 공급되지 않으면 휘발 | 영속성이 있음 |
| **가격**  | 비쌈       | 저렴함         |

> 데이터베이스의 데이터는 결국 디스크에 저장됨  
> 따라서 **데이터베이스 성능의 핵심은 디스크 I/O(입출력) 최소화**에 있음


#### 디스크 I/O 최소화를 위한 전략

1. ✅ **메모리 캐시 활용**
- 디스크 접근을 줄이기 위해 **메모리에 있는 데이터로 최대한 요청을 처리**해야 함.
- 이를 통해 **캐시 히트율**을 높이고 성능을 개선

2. ✅ **쓰기(Write) 최적화**
- 데이터를 바로 디스크에 쓰지 않고 **먼저 메모리에 저장**하여 랜덤 I/O를 줄임
- 하지만, 메모리에 저장된 데이터가 디스크에 기록되지 못한 채 서버가 다운되면 데이터가 유실될 수 있음

3. ✅ **WAL (Write Ahead Log) 사용**
- 데이터 유실을 방지하기 위해 **WAL(Write Ahead Log)** 를 사용하여 변경 이력을 먼저 로그로 남김
- 만약 서버가 다운되더라도 WAL을 이용해 데이터를 복구할 수 있음

#### 디스크 접근 방식

- **랜덤 I/O (Random I/O)**: 무작위 위치에서 데이터를 읽고 씀 → **성능 저하**
- **순차 I/O (Sequential I/O)**: 연속된 데이터 블록을 읽고 씀 → **성능 향상**

> 대부분의 트랜잭션은 무작위로 Write가 발생함  
> 따라서 **이를 지연시켜 랜덤 I/O 횟수를 줄이고, 대신 순차적 I/O를 유도하면 성능이 개선됨**

#### 💡 결론
✅ **업데이트가 올 때마다 디스크에 데이터를 저장하면 비효율적**  
✅ **메모리에 데이터를 쌓아두었다가 한 번에 디스크로 저장하는 것이 성능적으로 유리**  
✅ **디스크의 랜덤 I/O를 최소화하는 것이 데이터베이스 성능 최적화의 핵심**

<br/>

### 인덱스

인덱스는 **정렬된 자료 구조**로, **탐색 범위를 최소화**하여 조회 성능을 높인다.  
하지만 **삽입/삭제 성능**을 저하시킬 수 있다. 인덱스는 **조회 성능을 높이지만, 삽입/삭제 시 성능 저하**를 발생시킨다.

> **인덱스도 하나의 테이블이다.**

#### 자료구조

- **B+ Tree**
    - 삽입/삭제 시 항상 균형을 이룬다.
    - **리프 노드에 데이터 존재** → 연속 데이터 접근 시 유리.

- **MySQL**의 인덱스는 **PK 인덱스**와 매칭, **Oracle**은 데이터 주소를 사용한다.

#### 클러스터 인덱스

- **클러스터 인덱스**는 **데이터 위치를 결정**하는 키 값이다.
- **PK는 클러스터 인덱스**다.
- **PK 제외 인덱스**는 **PK를 포함**한다.
- **정렬된 순서**로 저장 → **삽입 시 성능 저하** 발생 가능.

#### 세컨더리 인덱스

- 세컨더리 인덱스만으로는 데이터를 찾을 수 없다.
- **세컨더리 인덱스**는 **PK를 포함**해 **커버링 인덱스**를 가능하게 한다.  
  → 테이블에 접근하지 않고 인덱스만으로 데이터를 조회할 수 있다.

#### 장점

1. **PK 활용 검색이 빠름**, 특히 **범위 검색**에서 성능 우위 → **공간적 캐시 이점**.
2. **세컨더리 인덱스는 PK 포함** → **커버링 인덱스** 활용 가능.

### 실습
```sql
# 데이터 분포도에 따라 같은 인덱스여도 성능이 다를 수 있다.
# 데이터 식별성에 따라 성능이 크게 달라짐

# 약 270만개 데이터 조회 40s 432ms > 인덱스를 주지 않았을 때보다 느려짐
# 범위의 조건을 좁힐 수 없음 (현재 1번 유저의 데이터만 있기에)
# 인덱스 테이블도 보고, 물리 테이블도 봐야 하기에 역효과 발생
create index POST__index_member_id
    on POST (memberId);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_member_id)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;

# 약 270만개 데이터 조회 2s 489ms
# 식별값이 많기에, 대신 데이터가 없는 memberId 인 경우 엄청 느려짐
create index POST__index_created_date
    on POST (createdDate);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_created_date)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;

# 약 270만개 데이터 조회 129ms
# 복합 인덱스로 추가
create index POST__index_member_id_created_date
    on POST (memberId, createdDate);

SELECT createdDate, memberId, count(id) as count
                    FROM POST use index (POST__index_member_id_created_date)
                    WHERE memberId = 1 AND createdDate BETWEEN '1900-01-01' AND '2025-03-01'
                    GROUP BY memberId, createdDate;
```

### 인덱스를 다룰 때 주의해야 할 점

#### 1. 인덱스 필드 가공
- 인덱스 필드를 가공하면 인덱스를 사용할 수 없음.
    - 예시: `age`가 인덱스가 있다고 해도, `WHERE age * 10 = 1` 쿼리에서는 인덱스를 사용하지 않음.
    - 예시: `WHERE age = '1'`과 같이 타입이 잘못된 경우에도 인덱스를 사용할 수 없음.

#### 2. 복합 인덱스
- 복합 인덱스는 인덱스에 명시된 순서대로 정렬됨.
    - 예시: `A, B` 복합 인덱스에서 `WHERE B`만 사용할 경우 인덱스를 사용하지 않음.
    - **제일 선두 컬럼이 중요**: 복합 인덱스에서 효율적인 사용을 위해 첫 번째 컬럼이 쿼리 조건에 있어야 함.

#### 3. 하나의 쿼리에는 하나의 인덱스만 사용
- 하나의 쿼리에서 여러 인덱스를 동시에 탐색하지 않음.
    - 예외적으로 `index merge hint`를 사용하면 여러 인덱스를 동시에 사용할 수 있음.
- `WHERE`, `ORDER BY`, `GROUP BY`와 같은 조건을 혼합하여 사용할 때 인덱스를 잘 고려해야 함.

#### 추가 사항
- 의도대로 인덱스가 동작하지 않을 수 있으므로, **`EXPLAIN`**을 통해 확인해야 함.
- 인덱스는 비용이 발생함. **쓰기를 희생하고 조회 성능을 얻는 것**이므로 이를 고려해야 함.
- **인덱스로만 해결할 수 있는 문제인지**를 신중하게 판단해야 함.


<br/>
<br/>

## 페이지네이션
: 데이터를 효율적으로 조회하기 위한 방법 중 하나로, 오프셋 기반과 커서 기반 페이징이 주로 사용된다.

- 오프셋 기반 페이징 : **오프셋 기반 페이징**은 `LIMIT`과 `OFFSET`을 사용하여 특정 위치부터 일정 개수의 데이터를 조회하는 방식
```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 30;
```
- 커서 기반 페이징 : 특정 키(예: id 또는 created_at)를 기준으로 데이터를 조회하는 방식

| 기준               | 오프셋 기반 페이징          | 커서 기반 페이징         |
|--------------------|--------------------|--------------------|
| **사용 편의성**    | 직관적인 페이지 번호 | `next_cursor` 사용 |
| **성능**          | 데이터가 많을수록 느려짐 | 데이터가 많아도 빠름 |
| **데이터 일관성**  | 새로운 데이터 삽입 시 페이지 변동 가능 | 데이터가 고정적으로 유지됨 |
| **전체 개수 조회 (`COUNT(*)`)** | 필요함 | 필요 없음 |

### 오프셋 기반의 페이징 구현의 문제
1. 전체 개수 조회 부담 (COUNT(*))
    - 마지막 페이지를 구하기 위해 전체 데이터 개수를 알아야 함.
    - 데이터가 많아질수록 COUNT(*) 연산이 성능 저하를 일으킬 수 있음.
2. 불필요한 데이터 조회
    - OFFSET이 증가할수록 불필요한 데이터 조회가 증가.
    - 예를 들어, OFFSET 10000을 조회하면 10000개의 데이터를 건너뛰는 데 불필요한 연산이 발생

#### 오프셋 기반 페이징 성능 개선 방법
1. 커버링 인덱스 (Covering Index) 활용
    - 쿼리에서 필요한 컬럼만 포함된 인덱스를 생성하여 COUNT 연산을 빠르게 수행
    - 인덱스만으로 데이터를 조회하면 테이블 전체 스캔을 방지할 수 있음
2. 카운트 쿼리 최적화
    - 캐싱을 활용하여 COUNT(*) 연산을 줄이거나, 대략적인 개수를 미리 계산하는 테이블을 운영

#### 커버링 인덱스
커버링 인덱스는 **테이블에 접근하지 않고, 인덱스만으로 데이터를 조회하는 방식**이다.  <br/>
즉, 쿼리를 실행할 때 **인덱스에 필요한 데이터가 모두 포함되어 있으면, 추가적인 테이블 조회를 생략할 수 있음** <br/>
<br/>

**커버링 인덱스의 장점**
- **불필요한 데이터 블록 접근 최소화**  
  → 테이블을 조회하는 I/O 비용 절감
- **쿼리 성능 최적화**  
  → 인덱스 스캔만으로 데이터를 가져올 수 있어 속도가 빠름

MySQL에서는 **PK(Primary Key)**가 **클러스터 인덱스(Clustered Index)**이기 때문에 커버링 인덱스를 활용하기 유리함 <br/>
<br/>

**커버링 인덱스를 위한 인덱스 설계** <br/>
예제: 회원 테이블에서 나이(age)와 이름(name)을 자주 조회하는 경우 <br/>
`CREATE INDEX idx_회원_나이_이름 ON 회원(나이, 이름);` <br/>
나이를 조건으로 필터링할 때, 이름도 인덱스에 포함되어 있어 테이블 조회 없이 처리 가능 → 커버링 인덱스 효과 발생!

### 커서 기반 페이징
특정 키(예: id 또는 created_at)를 기준으로 데이터를 조회하는 방식

```sql
SELECT * FROM posts WHERE created_at < '2024-01-01 00:00:00'
ORDER BY created_at DESC LIMIT 10;
```

> 이 방식은 OFFSET을 사용하지 않고, 마지막으로 조회한 데이터의 키 값을 기준으로 다음 데이터를 가져오기 때문에 성능이 향상됨

#### 커서 기반 페이징의 장점
1. 빠른 데이터 조회
    - OFFSET을 건너뛰지 않고 바로 필요한 데이터만 조회함
    - 대량의 데이터에서 조회 성능이 좋음
2. 일관된 데이터 제공
    - 새로운 데이터가 삽입되더라도 페이징 결과가 변하지 않음.
3. 카운트 쿼리 불필요
    - 전체 데이터 개수를 조회하지 않아 성능 부담이 적음

#### 커서 기반 페이징의 단점
1. 페이지 번호 방식의 UI 구현 어려움
    - 사용자가 특정 페이지로 바로 이동할 수 없음
    - next_cursor와 prev_cursor를 활용해야 함
2. 정렬 기준이 필요함
    - 반드시 정렬할 수 있는 고유한 키(예: id, created_at)가 필요

<br/>
<br/>