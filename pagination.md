## 페이지네이션
: 데이터를 효율적으로 조회하기 위한 방법 중 하나로, 오프셋 기반과 커서 기반 페이징이 주로 사용된다.

- 오프셋 기반 페이징 : **오프셋 기반 페이징**은 `LIMIT`과 `OFFSET`을 사용하여 특정 위치부터 일정 개수의 데이터를 조회하는 방식
```sql
SELECT * FROM posts ORDER BY created_at DESC LIMIT 10 OFFSET 30;
```
- 커서 기반 페이징 : 특정 키(예: id 또는 created_at)를 기준으로 데이터를 조회하는 방식

| 기준               | 오프셋 기반 페이징          | 커서 기반 페이징         |
|--------------------|--------------------|--------------------|
| **사용 편의성**    | 직관적인 페이지 번호 | `next_cursor` 사용 |
| **성능**          | 데이터가 많을수록 느려짐 | 데이터가 많아도 빠름 |
| **데이터 일관성**  | 새로운 데이터 삽입 시 페이지 변동 가능 | 데이터가 고정적으로 유지됨 |
| **전체 개수 조회 (`COUNT(*)`)** | 필요함 | 필요 없음 |

### 오프셋 기반의 페이징 구현의 문제
1. 전체 개수 조회 부담 (COUNT(*))
    - 마지막 페이지를 구하기 위해 전체 데이터 개수를 알아야 함.
    - 데이터가 많아질수록 COUNT(*) 연산이 성능 저하를 일으킬 수 있음.
2. 불필요한 데이터 조회
    - OFFSET이 증가할수록 불필요한 데이터 조회가 증가.
    - 예를 들어, OFFSET 10000을 조회하면 10000개의 데이터를 건너뛰는 데 불필요한 연산이 발생

#### 오프셋 기반 페이징 성능 개선 방법
1. 커버링 인덱스 (Covering Index) 활용
    - 쿼리에서 필요한 컬럼만 포함된 인덱스를 생성하여 COUNT 연산을 빠르게 수행
    - 인덱스만으로 데이터를 조회하면 테이블 전체 스캔을 방지할 수 있음
2. 카운트 쿼리 최적화
    - 캐싱을 활용하여 COUNT(*) 연산을 줄이거나, 대략적인 개수를 미리 계산하는 테이블을 운영

#### 커버링 인덱스
커버링 인덱스는 **테이블에 접근하지 않고, 인덱스만으로 데이터를 조회하는 방식**이다.  <br/>
즉, 쿼리를 실행할 때 **인덱스에 필요한 데이터가 모두 포함되어 있으면, 추가적인 테이블 조회를 생략할 수 있음** <br/>
<br/>

**커버링 인덱스의 장점**
- **불필요한 데이터 블록 접근 최소화**  
  → 테이블을 조회하는 I/O 비용 절감
- **쿼리 성능 최적화**  
  → 인덱스 스캔만으로 데이터를 가져올 수 있어 속도가 빠름

MySQL에서는 **PK(Primary Key)**가 **클러스터 인덱스(Clustered Index)**이기 때문에 커버링 인덱스를 활용하기 유리함 <br/>
<br/>

**커버링 인덱스를 위한 인덱스 설계** <br/>
예제: 회원 테이블에서 나이(age)와 이름(name)을 자주 조회하는 경우 <br/>
`CREATE INDEX idx_회원_나이_이름 ON 회원(나이, 이름);` <br/>
나이를 조건으로 필터링할 때, 이름도 인덱스에 포함되어 있어 테이블 조회 없이 처리 가능 → 커버링 인덱스 효과 발생!

### 커서 기반 페이징
특정 키(예: id 또는 created_at)를 기준으로 데이터를 조회하는 방식

```sql
SELECT * FROM posts WHERE created_at < '2024-01-01 00:00:00'
ORDER BY created_at DESC LIMIT 10;
```

> 이 방식은 OFFSET을 사용하지 않고, 마지막으로 조회한 데이터의 키 값을 기준으로 다음 데이터를 가져오기 때문에 성능이 향상됨

#### 커서 기반 페이징의 장점
1. 빠른 데이터 조회
    - OFFSET을 건너뛰지 않고 바로 필요한 데이터만 조회함
    - 대량의 데이터에서 조회 성능이 좋음
2. 일관된 데이터 제공
    - 새로운 데이터가 삽입되더라도 페이징 결과가 변하지 않음.
3. 카운트 쿼리 불필요
    - 전체 데이터 개수를 조회하지 않아 성능 부담이 적음

#### 커서 기반 페이징의 단점
1. 페이지 번호 방식의 UI 구현 어려움
    - 사용자가 특정 페이지로 바로 이동할 수 없음
    - next_cursor와 prev_cursor를 활용해야 함
2. 정렬 기준이 필요함
    - 반드시 정렬할 수 있는 고유한 키(예: id, created_at)가 필요

<br/>
<br/>