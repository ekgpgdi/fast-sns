## 동시성

### 멀티스레드 환경

- 대부분의 웹 서버는 여러 개의 요청을 동시에 처리할 수 있습니다.
- 이로 인해 작성한 코드 한 줄도 동시에 수행될 수 있습니다.

**동시성 이슈**
- 여러 연산들이 하나의 자원을 두고 경합할 때 데이터 정합성이 깨질 수 있습니다.

**데이터베이스에서 동시성 이슈가 발생하는 일반적인 패턴**
1. **공유 자원 조회**
2. **공유 자원 갱신**

→ 중간에 다른 오퍼레이션이 수행되면 동시성 이슈 발생할 수 있음

### 동시성 이슈가 어려운 이유
1. **로컬에서는 대부분 하나의 스레드로 테스트**  
   → 멀티스레드 환경에서의 문제를 미리 발견하기 어려움

2. **이슈가 발생하더라도 오류가 발생하지 않음**  
   → 동시성 이슈가 반드시 오류를 발생시키지 않음

3. **코드에서 잘 보이지 않음**  
   → 동시성 문제는 코드상에서 잘 드러나지 않음

4. **항상 발생하지 않고 비결정적으로 발생**  
   → 항상 동일한 조건에서 발생하지 않으며, 예측하기 어려운 경우가 많음

### 동시성 처리 방법: 쓰기락과 읽기락

동시성 처리 방법으로 가장 쉬운 방법은 **공유 자원에 대한 잠금을 획득해 줄 세우는 것**

- 락을 통해 동시성을 제어할 때는 **락의 범위를 최소화**하는 것이 중요함
- MySQL에서는 트랜잭션의 **커밋** 혹은 **롤백** 시점에 잠금이 풀림. 즉, **트랜잭션이 곧 락의 범위**임
- **트랜잭션에서 수행하는 작업을 최소화**하는 것이 중요함

#### 락 종류
|                      | 읽기락 (Shared Lock) | 쓰기락 (Exclusive Lock) |
|----------------------|----------------------|-------------------------|
| **읽기락**            | O                    | 대기                    |
| **쓰기락**            | 대기                 | 대기                    |

- **읽기락 (Shared Lock)**: `SELECT ... FROM SHARE`
- **쓰기락 (Exclusive Lock)**: `SELECT ... FOR UPDATE`

MySQL에서는 **일반 SELECT**는 **non-blocking consistent read**로 동작 <br/>
**undo log**를 사용하여 원본 데이터가 변경되었을 때, 커밋되기 전의 데이터를 계속 보관하기에 가능

### MySQL 잠금: 인덱스 잠금

- **MySQL의 잠금은 row가 아니라 인덱스**를 잠금
- 인덱스가 없는 조건으로 **Locking Read**를 수행하면 불필요한 데이터들이 잠길 수 있음

**예시:**

`memberId`에 대한 인덱스가 있을 때:

```mysql
start transaction ;
select * from POST where memberId = 1 and contents = 'string' for update;
```
memberId = 1인 모든 데이터에 락이 걸림 <br/>
락을 확인하려면 `select * from performance_schema.data_locks;` 사용 <br/>

```mysql
select * from performance_schema.data_locks; # 락 확인 (LOCK_MODE X 는 쓰기락)
select * from information_schema.innodb_trx; # 실행 중인 트랜잭션 확인
```

다른 트랜잭션에서 다른 데이터를 조회할 때 LOCK_WAITING 상태로 대기:
```java
start transaction;
select * from POST where memberId = 1 and contents = 'another string' for update;
commit;
```

> 따라서 MySQL 잠금은 인덱스를 확인하고 사용해야 불필요한 데이터 잠금을 방지할 수 있음

### 비관적 락과 낙관적 락

#### 비관적 락 (Pessimistic Lock)

- **락을 통해 줄을 세우는 방식**
- **락을 획득한 후 작업을 진행**하며, 다른 트랜잭션은 락을 대기
- 동시성 이슈가 발생할 가능성이 높다고 판단될 때 사용

**단점**
- 동시성 이슈가 빈번하지 않더라도 **불필요한 대기 상태**를 유발
- 성능 저하를 초래할 수 있음

#### 낙관적 락 (Optimistic Lock)

- **동시성 이슈가 빈번하지 않다고 판단될 때 사용**
- **어플리케이션에서 제어**하며, 락 없이 동작
- **동시성 이슈가 발생할 가능성을 적게 보고** 업데이트 시에만 충돌을 처리

<br/>

**제어 방식: CAS (Compare And Swap)**
- **버전 관리**: 버전을 두고 **리드시 버전**을 읽어옴
- **업데이트 시 버전도 함께 업데이트**
- **버전 불일치 시 실패 처리**: 업데이트 시 버전이 맞지 않으면 실패
   - 실패에 대한 처리를 **어플리케이션에서 직접 구현**해야 함

#### 결론

- **비관적 락**은 동시성 이슈를 방지하기 위해 락을 사용하나 성능 저하의 위험이 있음
- **낙관적 락**은 동시성 이슈가 드물다고 판단될 때 사용하며, **CAS**를 통해 버전 비교로 동시성 문제를 해결


